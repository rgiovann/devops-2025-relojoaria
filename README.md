# Jewelry Website Migration Project

## Project Overview

This project addresses a real-world consulting scenario where a development company needs to rapidly deploy a jewelry website for a new client by leveraging an existing solution originally built for a previous costume jewelry store client. The challenge involves migrating the infrastructure from Azure to AWS while optimizing costs, implementing security best practices, and automating the deployment process.

## Business Context

A consulting company has been tasked with bringing a new client's jewelry website online as quickly as possible. The technical lead identified that a previous project for an old client (costume jewelry store) shares significant similarities with the new requirements, presenting an opportunity for efficient code reuse with necessary adaptations.

### New Client Requirements

- Infrastructure must run on AWS
- Datacenter location: us-east-2 (Ohio region)
- All operations must be executable via make commands
- Cost optimization is a priority
- Security measures must be in place
- Automated deployment pipeline required
- Multi-engineer environment (shared AWS account)

## Technical Solution

### Application Stack

The jewelry website is built with modern web technologies:

- **Frontend Framework**: Vue.js 3 with Vite build system
- **Web Server**: Nginx (Alpine-based)
- **Containerization**: Docker multi-stage build
- **Runtime**: Node.js 18 for build process

The application features:
- Responsive product catalog
- Multi-section navigation (Home, Products, About, Contact)
- Mobile-optimized layout
- Portuguese language interface

### Migration Strategy

#### Phase 1: Cost Analysis

**Important**: Due to the unavailability of the original Azure infrastructure from the legacy project, the Azure cost baseline was estimated using an AI-generated `plan.json` file based on the original `main.tf` configuration. Similarly, the AWS Terraform configuration used for Infracost analysis was generated by AI through conversion from the CloudFormation template, as automated tools like `cf2tf` were unavailable or non-functional.

While these files were AI-generated, the cost estimates produced by Infracost are reliable as they query the official AWS Price List API and Azure pricing databases. The comparative analysis provides accurate baseline costs for both cloud providers, validating the cost optimization decisions made during the migration process.

This approach represents a common real-world scenario where direct access to legacy infrastructure may be restricted, requiring engineers to work with estimated configurations and available documentation.

A comprehensive cost comparison was performed between the original Azure infrastructure and the proposed AWS solution using Infracost:

**Original Azure Infrastructure:**
```
azurerm_linux_virtual_machine.main (Standard_B1s)    $7.59/month
azurerm_public_ip.main (static, regional)            $3.65/month
Storage (S4, LRS)                                     $1.54/month
---------------------------------------------------------------
TOTAL:                                               $12.78/month
```

**Target AWS Infrastructure:**
```
aws_instance.ec2_instance (t2.micro)                  $8.47/month
EBS Storage (gp3, 8GB)                                $0.64/month
---------------------------------------------------------------
TOTAL:                                                $9.11/month
```

**Cost Savings: $3.67/month (28.7% reduction)**

Key cost optimization decisions:
- Selected t2.micro instance type (AWS Free Tier eligible for first 12 months)
- Implemented gp3 EBS volumes (20% cheaper than gp2 with better performance baseline)
- Minimized storage to 8GB (sufficient for containerized application)
- Eliminated static IP reservation costs (using dynamic public IP)
- Configured automatic resource cleanup on instance termination

#### Phase 2: Infrastructure as Code

The infrastructure is defined using AWS CloudFormation, providing declarative infrastructure management with the following components:

**CloudFormation Template (relojoaria_aws.yaml):**

1. **Parameters:**
   - VpcId: Existing VPC identifier for network isolation
   - SubnetId: Target subnet for instance placement
   - KeyName: SSH key pair for secure access

2. **Resources:**
   - **Security Group (InstanceSecurityGroup):**
     - Ingress: SSH (port 22) and HTTP (port 8080)
     - Egress: Unrestricted (implicit)
     - VPC-scoped for network isolation
   
   - **EC2 Instance (EC2Instance):**
     - AMI: ami-011e7b514a4f15472 (Debian 12)
     - Instance Type: t2.micro
     - Storage: 8GB gp3 EBS volume
     - Network: Public IP auto-assignment enabled
     - UserData: Automated provisioning script

3. **Outputs:**
   - InstanceId: EC2 instance identifier
   - PublicIp: Dynamically assigned public IP
   - PublicDns: Public DNS hostname
   - SecurityGroupId: Security group identifier

**Automated Provisioning (UserData Script):**
```bash
- System updates and Docker installation
- Git repository cloning
- Docker image building
- Container deployment on port 8080
- Service persistence configuration
```

#### Phase 3: Build Automation

**Makefile Implementation:**

The project includes a comprehensive Makefile that abstracts AWS CLI complexity into simple, memorable commands:

```makefile
Variables:
- STACK_NAME: relojoaria-aws-stack
- REGION: us-east-2
- TEMPLATE: relojoaria_aws.yaml
- VPC_ID, SUBNET_ID, KEY_NAME: Infrastructure parameters

Targets:
- make run: Creates stack with validation and waits for completion
- make destroy: Deletes stack and waits for cleanup
- make status: Queries current stack status
- make validate: Validates CloudFormation template syntax
- make ip: Retrieves and displays public IP address
```

Key features:
- Pre-flight template validation
- Synchronous operations with wait conditions
- Automatic output retrieval
- Error handling and status reporting
- Idempotent stack creation

#### Phase 4: CI/CD Pipeline

**GitHub Actions Workflow (deploy_relojoaria.yaml):**

Automated deployment pipeline with the following stages:

1. **Code Checkout**: Repository clone using actions/checkout@v4

2. **AWS Authentication**: Credential configuration via GitHub Secrets
   - AWS_ACCESS_KEY_ID
   - AWS_SECRET_ACCESS_KEY
   - Region: us-east-2

3. **SSH Key Management**: PEM key provisioning for instance access
   - Secure storage in GitHub Secrets
   - Runtime extraction to ~/.ssh/
   - Proper permissions (600)

4. **Template Validation**: CloudFormation syntax verification

5. **Stack Deployment**: Intelligent create-or-update logic
   - Checks for existing stack
   - Updates if exists, creates if new
   - Handles "no changes" scenarios gracefully
   - Waits for operation completion

6. **Post-Deployment**: Public IP retrieval and display

Trigger: Automatic execution on push to main branch

#### Phase 5: Security Implementation

Security measures integrated throughout the solution:

**Network Security:**
- Security Group with principle of least privilege
- SSH access restricted to port 22 (should be further restricted by source IP in production)
- Application access limited to port 8080
- VPC isolation for network segmentation

**Access Control:**
- SSH key-based authentication (no password access)
- Private key stored securely in GitHub Secrets
- Instance profile IAM roles (when needed)

**Application Security:**
- Docker containerization for process isolation
- Non-root container execution
- Minimal base images (Alpine Linux)
- Automated security updates via UserData

**Operational Security:**
- Resource tagging for ownership tracking
- CloudFormation change sets for audit trail
- Automated deployments reduce human error
- Infrastructure as Code for version control

**Multi-Engineer Considerations:**
- Unique stack names prevent conflicts
- Tagged resources for identification
- Parameterized configurations
- Documented deployment procedures

## Project Artifacts

### 1. Application Source Code

**Dockerfile:**
- Multi-stage build for optimized image size
- Node.js 18 Alpine for build stage
- Nginx Alpine for production runtime
- Port 80 exposure (mapped to 8080 on host)

**package.json:**
- Vue.js 3 framework dependency
- Vite build tooling
- Development and production scripts
- Security audit capability

**src/App.vue:**
- Single-page application component
- Product catalog management
- Reactive navigation system
- Responsive CSS grid layout

**src/main.js:**
- Vue application bootstrap
- Component mounting

**vite.config.js:**
- Build configuration
- Vue plugin integration
- Output directory specification

### 2. Infrastructure as Code

**relojoaria_aws.yaml:**
Complete CloudFormation template defining:
- EC2 compute resources
- Security Group rules
- Network configurations
- Storage specifications
- Automated provisioning logic
- Stack outputs

### 3. Automation Scripts

**Makefile:**
Command orchestration providing:
- `make run`: Full stack deployment
- `make destroy`: Complete resource cleanup
- `make status`: Stack state verification
- `make validate`: Template syntax checking
- `make ip`: Public IP retrieval

### 4. CI/CD Pipeline

**.github/workflows/deploy_relojoaria.yaml:**
Automated deployment workflow including:
- Repository checkout
- AWS credential configuration
- SSH key provisioning
- Template validation
- Intelligent stack deployment
- Post-deployment verification

## Deployment Instructions

### Prerequisites

- AWS CLI configured with appropriate credentials
- AWS account with VPC and subnet created
- EC2 key pair generated
- Make utility installed
- Git repository cloned

### Local Deployment

```bash
# Clone repository
git clone <repository-url>
cd <repository-directory>

# Validate template
make validate

# Deploy stack
make run

# Check deployment status
make status

# Retrieve application URL
make ip

# Access application
curl http://<public-ip>:8080
```

### Automated Deployment

```bash
# Configure GitHub Secrets:
# - AWS_ACCESS_KEY_ID
# - AWS_SECRET_ACCESS_KEY
# - PEM_RELOJOARIA

# Push to main branch
git add .
git commit -m "Deploy jewelry website"
git push origin main

# Monitor GitHub Actions workflow
# Access application at displayed URL
```

### Cleanup

```bash
# Remove all resources
make destroy

# Verify deletion
make status
```

## Cost Optimization Summary

The migration from Azure to AWS achieved significant cost savings:

- **Monthly Cost Reduction**: $3.67 (28.7% decrease)
- **Annual Savings**: $44.04
- **AWS Free Tier Eligibility**: First 12 months free for t2.micro instances (750 hours/month)
- **Potential First-Year Savings**: $145.68 (including Free Tier)

Optimization techniques applied:
- Right-sized instance selection
- Storage type optimization (gp3 vs gp2)
- Minimal storage allocation
- Elimination of unnecessary static IP costs
- Automated resource lifecycle management

## Technical Achievements

1. **Cost Optimization (5%)**: 28.7% cost reduction with detailed Infracost analysis
2. **CI/CD Pipeline (5%)**: Fully automated GitHub Actions workflow
3. **AWS Migration (50%)**: Complete infrastructure migration with CloudFormation
4. **Security (30%)**: Multi-layered security implementation
5. **Documentation (10%)**: Comprehensive technical documentation


## Repository Structure

```
.
├── .github/
│   └── workflows/
│       └── deploy_relojoaria.yaml
├── src/
│   ├── App.vue
│   └── main.js
├── Dockerfile
├── Makefile
├── package.json
├── relojoaria_aws.yaml
├── vite.config.js
└── README.md
```

## License

This project is proprietary software developed for +Devs2Blu educational purposes.

---

**Final Project for IaC Module of +Devs2Blu DevOps Program - 2025 Edition**

**Author: Giovanni Leopoldo Rozza**